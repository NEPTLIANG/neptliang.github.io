---
layout:       post
title:        "《高性能JavaScript》中的重绘与重排"
subtitle:     "undefined"
date:         2025-03-06 21:18:59
author:       "NeptLiang"
header-img:   "img/home-bg.jpg"
header-mask:  0.3
catalog:      true
multilingual: false
tags:
    - FrontEnd
---


19个笔记


> 浏览器下载完页面中的所有组件——HTML 标记、JavaScript、CSS、图片——之后会解析并生成两个内部数据结构：
> 
> **DOM树**
> 
> 表示页面结构
> 
> **渲染树**
> 
> 表示DOM节点如何显示

* 当DOM的变化影响了元素的几何属性（宽和高），浏览器需要重新计算元素的几何属性，同样其他元素的几何属性和位置也会因此受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。这个过程称为 **“重排(reflow)”**。
    * 比如改变边框宽度或给段落增加文字，导致行数增加
* 完成重排后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为 **“重绘(repaint)”**。
    并不是所有的DOM 变化都会影响几何属性。
    * 例如，改变一个元素的背景色并不会影响它的宽和高。在这种情况下，只会发生一次重绘（不需要重排），因为元素的布局并没有改变。

> 重绘和重排操作都是代价昂贵的操作，它们会导致Web应用程序的UI反应迟钝。

### 3.3.1 重排何时发生？

> 下述情况中会发生重排：
> * 添加或删除可见的DOM元素
> * 元素位置改变
> * 元素尺寸改变（包括：外边距、内边距、边框厚度、宽度、高度等属性改变）
> * 内容改变，例如：文本改变或图片被另一个不同尺寸的图片替代
> * 页面渲染器初始化
> * 浏览器窗口尺寸改变

> 有些改变会触发整个页面的重排：例如，当滚动条出现时。

### 3.3.2 渲染树变化的排队与刷新

> 由于每次重排都会产生计算消耗，**大多数浏览器通过队列化修改并批量执行来优化重排过程**。然而，你可能会（经常不知不觉）强制刷新队列并要求计划任务立刻执行。**获取布局信息的操作会导致列队刷新，比如以下方法**：
> * offsetTop, offsetLeft, offsetWidth, offsetHeight
> * scrollTop, scrollLeft, scrollWidth, scrollHeight
> * clientTop, clientLeft, clientWidth, clientHeight
> * getComputedStyle() (currentStyle in IE)

> 在修改样式的过程中，最好避免使用上面列出的属性。它们都会刷新渲染队列，即使你是在获取最近未发生改变的或者与最新改变无关的布局信息。

> 一个更有效率的方法是**不要在布局信息改变时查询它**。

### 3.3.3 最小化重绘和重排

#### 改变样式

> **合并所有的改变然后一次处理**，这样只会修改DOM一次。
> * 使用**cssText**属性可以实现
> * 另一个一次性修改样式的办法是修改CSS的**class**名称，而不是修改内联样式。这种方法适用于那些不依赖于运行逻辑和计算的情况。改变CSS的class名称的方法更清晰，更易于维护；它有助于保持你的脚本与免除显示性代码，尽管**它可能带来轻微的性能影响，因为改变类时需要检查级联样式**。

#### 批量修改DOM

> 当你需要对DOM元素进行一系列操作时，可以通过以下步骤来减少重绘和重排的次数：
> 1. 使元素脱离文档流
> 2. 对其应用多重改变
> 3. 把元素带回文档中

有三种基本方法可以使DOM脱离文档：
* 隐藏元素，修改应用，重新显示。
  * 改变display属性
* 使用文档片断(docuement fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。
* 将原始元素拷贝到一个脱离文档的节点中，修改副本，完成后再替换原始元素。

> *文档片断是个轻量级的document 对象，它的设计初衷就是为了完成这类任务——更新和移动节点。*

> **推荐尽可能地使用文档片断（第二个方案），因为它们所产生的DOM遍历和重排次数最少。**

### 3.3.4 缓存布局信息

> 尽量减少布局信息的获取次数，获取后把它赋值给局部变量，然后再操作局部变量

### 3.3.5 让元素脱离动画流

> 1. 使用绝对位置定位页面上的动画元素，将其脱离文档流。
> 2. 让元素动起来。当它扩大时，会临时覆盖部分页面。但这只是页面一个小区域的重绘过程，不会产生重排并重绘页面的大部分内容。
> 3. 当动画结束时恢复定位，从而只会下移一次文档的其他元素。

### 3.3.6 IE和：hover

> 如果你有大量元素使用了：hover，那么会降低响应速度

> 在元素很多时应避免使用这种效果，比如很大的表格或很长的列表


---

***`//End of Article`***

---


![公众号二维码](https://neptliang.github.io/img/Article/WeChatBlog.png)